---
title: "GHC: Present and Future"
venue: Boston Haskell
author: Ben Gamari
date: 24 May 2017
---

## GHC 8.2 in a nutshell

 * Focus on consolidation and stabilization
 
 * Compiler performance

 * Lots of exciting incremental improvements

# Performance
## Performance

 * Improvements all over the compiler. To name just a few...

    - More efficient handling of names
    - Lazy deserialization of interface files
    - Fix laziness of instance visibility check
    - Early inlining
   
 * But don't take my word for it...

## Performance by the numbers

![](allocs.pdf)

## Performance by the numbers

```
-------------------------------------------------
   Program            8.0.2.log    8.2.1-rc2.log
-------------------------------------------------

Compile Allocations
   -1 s.d.                -----           -35.7%
   +1 s.d.                -----            -3.3%
   Average                -----           -21.2%

Compile Times
   -1 s.d.                -----           -23.2%
   +1 s.d.                -----            +7.1%
   Average                -----            -9.3%
```

## Performance by the numbers

Chris Allen's `bloodhound` package

| compiler | user time (seconds) |
|---------:|---------------------|
|      7.8 |              129.12 |
|     7.10 |              163.38 |
|      8.0 |              147.44 |
|      8.2 |              126.37 |


# New Typeable


## `Typeable` (`@simonpj`, `@goldfire`, `@bgamari`)

```haskell
-- | Runtime value representing a type.
data TypeRep

class Typeable a where
    typeRep :: Proxy a -> TypeRep
```

Introduced long ago, used by numerous consumers including `wai`, Cloud Haskell,
`HList`, and many others.

## `Data.Dynamic`

```haskell
data Dynamic where
    Dyn :: TypeRep -> a -> Dynamic
    
fromDyn :: forall a. Typeable a => Dynamic -> Maybe a
fromDyn (Dyn rep x)
  | rep == rep' = Just $ unsafeCoerce x   -- the horror!
  | otherwise   = Nothing
  where rep' = typeRep (Proxy @a)
```

. . .

```haskell
-- Function application
appDyn :: Dynamic        -- a -> b
       -> Dynamic        -- a
       -> Maybe Dynamic  -- b
appDyn f x = {- more unsafe trickiness -}
```

## New `Typeable` (or rather, `Reflection`)

Why not add an index to `TypeRep` [@typed-reflection-in-haskell]?

```haskell
-- Runtime evidence of the identity of a type
data TypeRep a

class Typeable a where
    typeRep :: forall a. TypeRep a

data a :~: b where
    Refl :: (a ~ b) => a :~: b

eqTypeRep :: TypeRep a -> TypeRep b -> Maybe (a :~: b)
```

## `Dynamic` with reflection

<div class=notes>
Now the compiler can see that the `TypeRep` represents the type of the dynamic
value,
</div>

```haskell
data Dynamic where
    Dyn :: TypeRep a -> a -> Dynamic
```

. . .

```haskell
fromDyn :: forall a. Typeable a => Dynamic -> Maybe a
fromDyn (Dyn rep x)
  | Just Refl <- rep `eqTypeRep` rep' = Just x  -- yay!
  | otherwise                         = Nothing
  where rep' = typeRep @a
```

## `appDyn` with reflection

```haskell
pattern Fun :: forall fun. ()
            => forall arg res. (fun ~ (arg -> res))
            => TypeRep arg
            -> TypeRep res
            -> TypeRep fun

appDyn :: Dynamic -> Dynamic -> Maybe Dynamic
appDyn (Dyn ra xa) (Dyn rb xb)
  | Fun argRep resRep <- ra
  , Just Refl <- rb `eqTypeRep` argRep
  = Just $ Dyn (xa xb)

  | otherwise
  = Nothing
```

## What else is new?

* Reflection on kinds:

    ```haskell
    >>> typeRepKind (typeRep @Maybe)
    * -> *
    ```

. . .

* Can represent more types; lots of papercuts fixed:

    ```haskell
    >>> typeRepKind (typeRep @GHC.Types.'I#)
    Int# -> Int
    ```

    (Still no ability to represent higher-rank types)

# Compact regions (`@ezyang` et al.)
## Compact regions

Collect a closed set of heap objects into a single "compact region".

In exchange we get,

 * Reduced GC tracing costs in programs of the form

    ```haskell
    let someLargeValue = ...
    in someLongComputation
    ```

 * Efficient (possibly zero-copy) serialization
 
At the expense of prompt GC.

# Debugging and profiling (`@bgamari`, `@scpwm`)

## DWARF debug information (`ghc -g`)

* Introduced in 7.10
* Improved in 8.0
* Finally stable in 8.2
* Future directions: <https://ghc.haskell.org/trac/ghc/wiki/DWARF/Status>

(Demo)

See `GHC.ExecutionStack` for stack traces from within Haskell.

## What does it require?

* Currently Linux, amd64 and, if you're feeling lucky, i386
* `libdw`, GHC configured with `--enable-dwarf-unwind`
* All linked code (including core libraries) built with `ghc -g`
* Packaging questions remain: 
    - Should we produce binary distributions with debug symbols? 
    - For which distributions?
  
## Future: Statistical profiling?

* "Cost-free" profiling: won't affect code generation
* Sample on a wider variety of events than CC profiler:
    - Allocations
    - CPU cycles
    - Architectural performance counters: Cache misses, stalls, etc.
    - Black-hole block events
    - Spark fizzles
    - etc.
* Challenges:
    - GHC's calling convention is atypical, precluding use of the system's
      native callgraph collection mechanism (e.g. `perf_events`)
    - Reasoning about causality in an optimized lazy language is quite difficult, requiring more information and more sophisticated analysis tools than typically needed for more traditional languages


## Future: Statistical profiling: Four roads

a. Build Haskell-specific tooling
    - Pro: Easier to address Haskell-specific challenges
    - Pro: Generally platform independent
    - Con: Requires developing a whole tooling ecosystem
    - Prototype: http://github.com/bgamari/tree/

b. Piggyback on native tools (e.g. `perf`)
    - Pro: Integrates with rest of system
    - Con: Requires tricky integration
    - Con: Difficult to reach feature-parity with Haskell-specific option
    - Con: Necessarily platform specific
    - Another option: Change GHC calling convention to match native

c. Don't bother

## Future: Stack traces on exceptions?

* Tricky trade-offs need to be made
* Stacktrace collection is expensive
* Haskell programs sometimes use (asynchronous) exceptions for flow-control
* Ensuring compatibility
* See <https://ghc.haskell.org/trac/ghc/wiki/Exceptions/StackTraces>


## Cost-center profiler modernization (`@bgamari`)

* Heap profiler can now emit sample data to event log
    - Allows correlation with other program events
    - Live-streaming of profile data (new in 8.2, `@alexbiehl`)
    - Compile with `ghc -eventlog -prof`
    - Run program with `+RTS -l -h`
* New JSON format for `.prof` files for easier integration with tooling
    - Compile with `ghc -prof`
    - Run program with `+RTS -pj`

# Deriving strategies (`@RyanGlScott`)
## Deriving strategies

Solves the long-standing friction between `DeriveAnyClass` and `GeneralizedNewtypeDeriving`
```haskell
data MyType = ...
            deriving (Eq, Show, Generic)
            deriving anyclass (Binary)
```


## Other great things

 * More robust levity polymorphism story (`@goldfire` & `@simonpj`)
 * `StaticPointers` support in GHCi (`@bgamari`)
 * Unpacked sum types (`@osa1`)
 * NUMA support in the runtime system (`@simonmar`)
 * Join points (`@lukemaurer`)
 * Backpack! (`@ezyang`)
 * The long-awaited `OverloadedRecordFields` (`@adamgundry`)
 * Interface-file determinism (`@niteria`)
    - A boon for distributed and caching build systems
 * Improved cross-compilation support (`@angerman` & `@bgamari`)
 
## Other great things

 * Pretty error messages (`@Rufflewind`):
 
   ![](pretty-error.png)

<div class=notes>
* I would like to see more in this direction.
* We are really close and the direction is clear (#8809)
</div>
 
## Other great things to come

 * Loop annotations (`@tjakway`)
 
    * Teach backend to recognize loops, be more careful in register allocation and code gen.
      <div class=notes>May fit nicely with join points work (#13567)</div>

 * Better support for developer tooling
    * Make `-fno-code` usable for `ghc-mod` and friends (`@duog`)
    * Prettier error messages (`@adinapoli`)
    
 * A new Shake-based build system, Hadrian (`@snowleopard`)
 
 * Linear types (Tweag I/O)
 
 * Dependent Haskell (`@goldfire`)
 
 * Dynamic linking on Windows (`@Phyx`)

## Coming changes in GHC development

 * Improved CI infrastructure (`@davean`, `@bgamari`)
 
    - Faster turnaround for contributors
    - Nightly builds
    - Regular testing of more of GHC's surface area
    - More efficient release process
    - Less tree brokenness
    
 *     

# Thank you!

## References {.allowframebreaks}
